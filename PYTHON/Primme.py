# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
Find a few eigenvalues and eigenvectors, and also singular triplets of a matrix.
Uses PRIMME: https://github.com/primme/primme

"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Primme')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Primme')
    _Primme = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Primme', [dirname(__file__)])
        except ImportError:
            import _Primme
            return _Primme
        if fp is not None:
            try:
                _mod = imp.load_module('_Primme', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _Primme = swig_import_helper()
    del swig_import_helper
else:
    import _Primme
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x



__all__ = ['PrimmeParams', 'sprimme', 'cprimme', 'dprimme', 'zprimme', 'eigsh', 'PrimmeError', 'PRIMME_Arnoldi', 'PRIMME_DEFAULT_METHOD', 'PRIMME_DEFAULT_MIN_MATVECS', 'PRIMME_DEFAULT_MIN_TIME', 'PRIMME_DYNAMIC', 'PRIMME_GD', 'PRIMME_GD_Olsen_plusK', 'PRIMME_GD_plusK', 'PRIMME_JDQMR', 'PRIMME_JDQMR_ETol', 'PRIMME_JDQR', 'PRIMME_JD_Olsen_plusK', 'PRIMME_LOBPCG_OrthoBasis', 'PRIMME_LOBPCG_OrthoBasis_Window', 'PRIMME_RQI', 'PRIMME_SUBSPACE_ITERATION', 'primme_adaptive', 'primme_adaptive_ETolerance', 'primme_closest_abs', 'primme_closest_geq', 'primme_closest_leq', 'primme_decreasing_LTolerance', 'primme_dtr', 'primme_full_LTolerance', 'primme_init_default', 'primme_init_krylov', 'primme_init_random', 'primme_init_user', 'primme_largest', 'primme_largest_abs', 'primme_proj_RR', 'primme_proj_default', 'primme_proj_harmonic', 'primme_proj_refined', 'primme_smallest', 'primme_thick', 'PrimmeSvdsParams', 'svds', 'primme_svds_augmented', 'primme_svds_closest_abs', 'primme_svds_default', 'primme_svds_hybrid', 'primme_svds_largest', 'primme_svds_normalequations', 'primme_svds_op_AAt', 'primme_svds_op_AtA', 'primme_svds_op_augmented', 'primme_svds_op_none', 'primme_svds_smallest', 'sprimme_svds', 'cprimme_svds', 'dprimme_svds', 'zprimme_svds', 'PrimmeSvdsError']

primme_smallest = _Primme.primme_smallest
primme_largest = _Primme.primme_largest
primme_closest_geq = _Primme.primme_closest_geq
primme_closest_leq = _Primme.primme_closest_leq
primme_closest_abs = _Primme.primme_closest_abs
primme_largest_abs = _Primme.primme_largest_abs
primme_proj_default = _Primme.primme_proj_default
primme_proj_RR = _Primme.primme_proj_RR
primme_proj_harmonic = _Primme.primme_proj_harmonic
primme_proj_refined = _Primme.primme_proj_refined
primme_init_default = _Primme.primme_init_default
primme_init_krylov = _Primme.primme_init_krylov
primme_init_random = _Primme.primme_init_random
primme_init_user = _Primme.primme_init_user
primme_thick = _Primme.primme_thick
primme_dtr = _Primme.primme_dtr
primme_full_LTolerance = _Primme.primme_full_LTolerance
primme_decreasing_LTolerance = _Primme.primme_decreasing_LTolerance
primme_adaptive_ETolerance = _Primme.primme_adaptive_ETolerance
primme_adaptive = _Primme.primme_adaptive
class primme_stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_stats, name)
    __repr__ = _swig_repr
    __swig_setmethods__["numOuterIterations"] = _Primme.primme_stats_numOuterIterations_set
    __swig_getmethods__["numOuterIterations"] = _Primme.primme_stats_numOuterIterations_get
    if _newclass:
        numOuterIterations = _swig_property(_Primme.primme_stats_numOuterIterations_get, _Primme.primme_stats_numOuterIterations_set)
    __swig_setmethods__["numRestarts"] = _Primme.primme_stats_numRestarts_set
    __swig_getmethods__["numRestarts"] = _Primme.primme_stats_numRestarts_get
    if _newclass:
        numRestarts = _swig_property(_Primme.primme_stats_numRestarts_get, _Primme.primme_stats_numRestarts_set)
    __swig_setmethods__["numMatvecs"] = _Primme.primme_stats_numMatvecs_set
    __swig_getmethods__["numMatvecs"] = _Primme.primme_stats_numMatvecs_get
    if _newclass:
        numMatvecs = _swig_property(_Primme.primme_stats_numMatvecs_get, _Primme.primme_stats_numMatvecs_set)
    __swig_setmethods__["numPreconds"] = _Primme.primme_stats_numPreconds_set
    __swig_getmethods__["numPreconds"] = _Primme.primme_stats_numPreconds_get
    if _newclass:
        numPreconds = _swig_property(_Primme.primme_stats_numPreconds_get, _Primme.primme_stats_numPreconds_set)
    __swig_setmethods__["numGlobalSum"] = _Primme.primme_stats_numGlobalSum_set
    __swig_getmethods__["numGlobalSum"] = _Primme.primme_stats_numGlobalSum_get
    if _newclass:
        numGlobalSum = _swig_property(_Primme.primme_stats_numGlobalSum_get, _Primme.primme_stats_numGlobalSum_set)
    __swig_setmethods__["volumeGlobalSum"] = _Primme.primme_stats_volumeGlobalSum_set
    __swig_getmethods__["volumeGlobalSum"] = _Primme.primme_stats_volumeGlobalSum_get
    if _newclass:
        volumeGlobalSum = _swig_property(_Primme.primme_stats_volumeGlobalSum_get, _Primme.primme_stats_volumeGlobalSum_set)
    __swig_setmethods__["numOrthoInnerProds"] = _Primme.primme_stats_numOrthoInnerProds_set
    __swig_getmethods__["numOrthoInnerProds"] = _Primme.primme_stats_numOrthoInnerProds_get
    if _newclass:
        numOrthoInnerProds = _swig_property(_Primme.primme_stats_numOrthoInnerProds_get, _Primme.primme_stats_numOrthoInnerProds_set)
    __swig_setmethods__["elapsedTime"] = _Primme.primme_stats_elapsedTime_set
    __swig_getmethods__["elapsedTime"] = _Primme.primme_stats_elapsedTime_get
    if _newclass:
        elapsedTime = _swig_property(_Primme.primme_stats_elapsedTime_get, _Primme.primme_stats_elapsedTime_set)
    __swig_setmethods__["timeMatvec"] = _Primme.primme_stats_timeMatvec_set
    __swig_getmethods__["timeMatvec"] = _Primme.primme_stats_timeMatvec_get
    if _newclass:
        timeMatvec = _swig_property(_Primme.primme_stats_timeMatvec_get, _Primme.primme_stats_timeMatvec_set)
    __swig_setmethods__["timePrecond"] = _Primme.primme_stats_timePrecond_set
    __swig_getmethods__["timePrecond"] = _Primme.primme_stats_timePrecond_get
    if _newclass:
        timePrecond = _swig_property(_Primme.primme_stats_timePrecond_get, _Primme.primme_stats_timePrecond_set)
    __swig_setmethods__["timeOrtho"] = _Primme.primme_stats_timeOrtho_set
    __swig_getmethods__["timeOrtho"] = _Primme.primme_stats_timeOrtho_get
    if _newclass:
        timeOrtho = _swig_property(_Primme.primme_stats_timeOrtho_get, _Primme.primme_stats_timeOrtho_set)
    __swig_setmethods__["timeGlobalSum"] = _Primme.primme_stats_timeGlobalSum_set
    __swig_getmethods__["timeGlobalSum"] = _Primme.primme_stats_timeGlobalSum_get
    if _newclass:
        timeGlobalSum = _swig_property(_Primme.primme_stats_timeGlobalSum_get, _Primme.primme_stats_timeGlobalSum_set)
    __swig_setmethods__["estimateMinEVal"] = _Primme.primme_stats_estimateMinEVal_set
    __swig_getmethods__["estimateMinEVal"] = _Primme.primme_stats_estimateMinEVal_get
    if _newclass:
        estimateMinEVal = _swig_property(_Primme.primme_stats_estimateMinEVal_get, _Primme.primme_stats_estimateMinEVal_set)
    __swig_setmethods__["estimateMaxEVal"] = _Primme.primme_stats_estimateMaxEVal_set
    __swig_getmethods__["estimateMaxEVal"] = _Primme.primme_stats_estimateMaxEVal_get
    if _newclass:
        estimateMaxEVal = _swig_property(_Primme.primme_stats_estimateMaxEVal_get, _Primme.primme_stats_estimateMaxEVal_set)
    __swig_setmethods__["estimateLargestSVal"] = _Primme.primme_stats_estimateLargestSVal_set
    __swig_getmethods__["estimateLargestSVal"] = _Primme.primme_stats_estimateLargestSVal_get
    if _newclass:
        estimateLargestSVal = _swig_property(_Primme.primme_stats_estimateLargestSVal_get, _Primme.primme_stats_estimateLargestSVal_set)
    __swig_setmethods__["maxConvTol"] = _Primme.primme_stats_maxConvTol_set
    __swig_getmethods__["maxConvTol"] = _Primme.primme_stats_maxConvTol_get
    if _newclass:
        maxConvTol = _swig_property(_Primme.primme_stats_maxConvTol_get, _Primme.primme_stats_maxConvTol_set)
    __swig_setmethods__["estimateResidualError"] = _Primme.primme_stats_estimateResidualError_set
    __swig_getmethods__["estimateResidualError"] = _Primme.primme_stats_estimateResidualError_get
    if _newclass:
        estimateResidualError = _swig_property(_Primme.primme_stats_estimateResidualError_get, _Primme.primme_stats_estimateResidualError_set)

    def __init__(self):
        this = _Primme.new_primme_stats()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_stats
    __del__ = lambda self: None
primme_stats_swigregister = _Primme.primme_stats_swigregister
primme_stats_swigregister(primme_stats)

class JD_projectors(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JD_projectors, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JD_projectors, name)
    __repr__ = _swig_repr
    __swig_setmethods__["LeftQ"] = _Primme.JD_projectors_LeftQ_set
    __swig_getmethods__["LeftQ"] = _Primme.JD_projectors_LeftQ_get
    if _newclass:
        LeftQ = _swig_property(_Primme.JD_projectors_LeftQ_get, _Primme.JD_projectors_LeftQ_set)
    __swig_setmethods__["LeftX"] = _Primme.JD_projectors_LeftX_set
    __swig_getmethods__["LeftX"] = _Primme.JD_projectors_LeftX_get
    if _newclass:
        LeftX = _swig_property(_Primme.JD_projectors_LeftX_get, _Primme.JD_projectors_LeftX_set)
    __swig_setmethods__["RightQ"] = _Primme.JD_projectors_RightQ_set
    __swig_getmethods__["RightQ"] = _Primme.JD_projectors_RightQ_get
    if _newclass:
        RightQ = _swig_property(_Primme.JD_projectors_RightQ_get, _Primme.JD_projectors_RightQ_set)
    __swig_setmethods__["RightX"] = _Primme.JD_projectors_RightX_set
    __swig_getmethods__["RightX"] = _Primme.JD_projectors_RightX_get
    if _newclass:
        RightX = _swig_property(_Primme.JD_projectors_RightX_get, _Primme.JD_projectors_RightX_set)
    __swig_setmethods__["SkewQ"] = _Primme.JD_projectors_SkewQ_set
    __swig_getmethods__["SkewQ"] = _Primme.JD_projectors_SkewQ_get
    if _newclass:
        SkewQ = _swig_property(_Primme.JD_projectors_SkewQ_get, _Primme.JD_projectors_SkewQ_set)
    __swig_setmethods__["SkewX"] = _Primme.JD_projectors_SkewX_set
    __swig_getmethods__["SkewX"] = _Primme.JD_projectors_SkewX_get
    if _newclass:
        SkewX = _swig_property(_Primme.JD_projectors_SkewX_get, _Primme.JD_projectors_SkewX_set)

    def __init__(self):
        this = _Primme.new_JD_projectors()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_JD_projectors
    __del__ = lambda self: None
JD_projectors_swigregister = _Primme.JD_projectors_swigregister
JD_projectors_swigregister(JD_projectors)

class projection_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, projection_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, projection_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["projection"] = _Primme.projection_params_projection_set
    __swig_getmethods__["projection"] = _Primme.projection_params_projection_get
    if _newclass:
        projection = _swig_property(_Primme.projection_params_projection_get, _Primme.projection_params_projection_set)

    def __init__(self):
        this = _Primme.new_projection_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_projection_params
    __del__ = lambda self: None
projection_params_swigregister = _Primme.projection_params_swigregister
projection_params_swigregister(projection_params)

class correction_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, correction_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, correction_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["precondition"] = _Primme.correction_params_precondition_set
    __swig_getmethods__["precondition"] = _Primme.correction_params_precondition_get
    if _newclass:
        precondition = _swig_property(_Primme.correction_params_precondition_get, _Primme.correction_params_precondition_set)
    __swig_setmethods__["robustShifts"] = _Primme.correction_params_robustShifts_set
    __swig_getmethods__["robustShifts"] = _Primme.correction_params_robustShifts_get
    if _newclass:
        robustShifts = _swig_property(_Primme.correction_params_robustShifts_get, _Primme.correction_params_robustShifts_set)
    __swig_setmethods__["maxInnerIterations"] = _Primme.correction_params_maxInnerIterations_set
    __swig_getmethods__["maxInnerIterations"] = _Primme.correction_params_maxInnerIterations_get
    if _newclass:
        maxInnerIterations = _swig_property(_Primme.correction_params_maxInnerIterations_get, _Primme.correction_params_maxInnerIterations_set)
    __swig_setmethods__["projectors"] = _Primme.correction_params_projectors_set
    __swig_getmethods__["projectors"] = _Primme.correction_params_projectors_get
    if _newclass:
        projectors = _swig_property(_Primme.correction_params_projectors_get, _Primme.correction_params_projectors_set)
    __swig_setmethods__["convTest"] = _Primme.correction_params_convTest_set
    __swig_getmethods__["convTest"] = _Primme.correction_params_convTest_get
    if _newclass:
        convTest = _swig_property(_Primme.correction_params_convTest_get, _Primme.correction_params_convTest_set)
    __swig_setmethods__["relTolBase"] = _Primme.correction_params_relTolBase_set
    __swig_getmethods__["relTolBase"] = _Primme.correction_params_relTolBase_get
    if _newclass:
        relTolBase = _swig_property(_Primme.correction_params_relTolBase_get, _Primme.correction_params_relTolBase_set)

    def __init__(self):
        this = _Primme.new_correction_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_correction_params
    __del__ = lambda self: None
correction_params_swigregister = _Primme.correction_params_swigregister
correction_params_swigregister(correction_params)

class restarting_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, restarting_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, restarting_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["scheme"] = _Primme.restarting_params_scheme_set
    __swig_getmethods__["scheme"] = _Primme.restarting_params_scheme_get
    if _newclass:
        scheme = _swig_property(_Primme.restarting_params_scheme_get, _Primme.restarting_params_scheme_set)
    __swig_setmethods__["maxPrevRetain"] = _Primme.restarting_params_maxPrevRetain_set
    __swig_getmethods__["maxPrevRetain"] = _Primme.restarting_params_maxPrevRetain_get
    if _newclass:
        maxPrevRetain = _swig_property(_Primme.restarting_params_maxPrevRetain_get, _Primme.restarting_params_maxPrevRetain_set)

    def __init__(self):
        this = _Primme.new_restarting_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_restarting_params
    __del__ = lambda self: None
restarting_params_swigregister = _Primme.restarting_params_swigregister
restarting_params_swigregister(restarting_params)

class primme_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["n"] = _Primme.primme_params_n_set
    __swig_getmethods__["n"] = _Primme.primme_params_n_get
    if _newclass:
        n = _swig_property(_Primme.primme_params_n_get, _Primme.primme_params_n_set)
    __swig_setmethods__["numProcs"] = _Primme.primme_params_numProcs_set
    __swig_getmethods__["numProcs"] = _Primme.primme_params_numProcs_get
    if _newclass:
        numProcs = _swig_property(_Primme.primme_params_numProcs_get, _Primme.primme_params_numProcs_set)
    __swig_setmethods__["procID"] = _Primme.primme_params_procID_set
    __swig_getmethods__["procID"] = _Primme.primme_params_procID_get
    if _newclass:
        procID = _swig_property(_Primme.primme_params_procID_get, _Primme.primme_params_procID_set)
    __swig_setmethods__["nLocal"] = _Primme.primme_params_nLocal_set
    __swig_getmethods__["nLocal"] = _Primme.primme_params_nLocal_get
    if _newclass:
        nLocal = _swig_property(_Primme.primme_params_nLocal_get, _Primme.primme_params_nLocal_set)
    __swig_setmethods__["globalSumReal"] = _Primme.primme_params_globalSumReal_set
    __swig_getmethods__["globalSumReal"] = _Primme.primme_params_globalSumReal_get
    if _newclass:
        globalSumReal = _swig_property(_Primme.primme_params_globalSumReal_get, _Primme.primme_params_globalSumReal_set)
    __swig_setmethods__["numEvals"] = _Primme.primme_params_numEvals_set
    __swig_getmethods__["numEvals"] = _Primme.primme_params_numEvals_get
    if _newclass:
        numEvals = _swig_property(_Primme.primme_params_numEvals_get, _Primme.primme_params_numEvals_set)
    __swig_setmethods__["target"] = _Primme.primme_params_target_set
    __swig_getmethods__["target"] = _Primme.primme_params_target_get
    if _newclass:
        target = _swig_property(_Primme.primme_params_target_get, _Primme.primme_params_target_set)
    __swig_setmethods__["dynamicMethodSwitch"] = _Primme.primme_params_dynamicMethodSwitch_set
    __swig_getmethods__["dynamicMethodSwitch"] = _Primme.primme_params_dynamicMethodSwitch_get
    if _newclass:
        dynamicMethodSwitch = _swig_property(_Primme.primme_params_dynamicMethodSwitch_get, _Primme.primme_params_dynamicMethodSwitch_set)
    __swig_setmethods__["locking"] = _Primme.primme_params_locking_set
    __swig_getmethods__["locking"] = _Primme.primme_params_locking_get
    if _newclass:
        locking = _swig_property(_Primme.primme_params_locking_get, _Primme.primme_params_locking_set)
    __swig_setmethods__["initSize"] = _Primme.primme_params_initSize_set
    __swig_getmethods__["initSize"] = _Primme.primme_params_initSize_get
    if _newclass:
        initSize = _swig_property(_Primme.primme_params_initSize_get, _Primme.primme_params_initSize_set)
    __swig_setmethods__["numOrthoConst"] = _Primme.primme_params_numOrthoConst_set
    __swig_getmethods__["numOrthoConst"] = _Primme.primme_params_numOrthoConst_get
    if _newclass:
        numOrthoConst = _swig_property(_Primme.primme_params_numOrthoConst_get, _Primme.primme_params_numOrthoConst_set)
    __swig_setmethods__["maxBasisSize"] = _Primme.primme_params_maxBasisSize_set
    __swig_getmethods__["maxBasisSize"] = _Primme.primme_params_maxBasisSize_get
    if _newclass:
        maxBasisSize = _swig_property(_Primme.primme_params_maxBasisSize_get, _Primme.primme_params_maxBasisSize_set)
    __swig_setmethods__["minRestartSize"] = _Primme.primme_params_minRestartSize_set
    __swig_getmethods__["minRestartSize"] = _Primme.primme_params_minRestartSize_get
    if _newclass:
        minRestartSize = _swig_property(_Primme.primme_params_minRestartSize_get, _Primme.primme_params_minRestartSize_set)
    __swig_setmethods__["maxBlockSize"] = _Primme.primme_params_maxBlockSize_set
    __swig_getmethods__["maxBlockSize"] = _Primme.primme_params_maxBlockSize_get
    if _newclass:
        maxBlockSize = _swig_property(_Primme.primme_params_maxBlockSize_get, _Primme.primme_params_maxBlockSize_set)
    __swig_setmethods__["maxMatvecs"] = _Primme.primme_params_maxMatvecs_set
    __swig_getmethods__["maxMatvecs"] = _Primme.primme_params_maxMatvecs_get
    if _newclass:
        maxMatvecs = _swig_property(_Primme.primme_params_maxMatvecs_get, _Primme.primme_params_maxMatvecs_set)
    __swig_setmethods__["maxOuterIterations"] = _Primme.primme_params_maxOuterIterations_set
    __swig_getmethods__["maxOuterIterations"] = _Primme.primme_params_maxOuterIterations_get
    if _newclass:
        maxOuterIterations = _swig_property(_Primme.primme_params_maxOuterIterations_get, _Primme.primme_params_maxOuterIterations_set)
    __swig_setmethods__["intWorkSize"] = _Primme.primme_params_intWorkSize_set
    __swig_getmethods__["intWorkSize"] = _Primme.primme_params_intWorkSize_get
    if _newclass:
        intWorkSize = _swig_property(_Primme.primme_params_intWorkSize_get, _Primme.primme_params_intWorkSize_set)
    __swig_setmethods__["realWorkSize"] = _Primme.primme_params_realWorkSize_set
    __swig_getmethods__["realWorkSize"] = _Primme.primme_params_realWorkSize_get
    if _newclass:
        realWorkSize = _swig_property(_Primme.primme_params_realWorkSize_get, _Primme.primme_params_realWorkSize_set)
    __swig_setmethods__["iseed"] = _Primme.primme_params_iseed_set
    __swig_getmethods__["iseed"] = _Primme.primme_params_iseed_get
    if _newclass:
        iseed = _swig_property(_Primme.primme_params_iseed_get, _Primme.primme_params_iseed_set)
    __swig_setmethods__["aNorm"] = _Primme.primme_params_aNorm_set
    __swig_getmethods__["aNorm"] = _Primme.primme_params_aNorm_get
    if _newclass:
        aNorm = _swig_property(_Primme.primme_params_aNorm_get, _Primme.primme_params_aNorm_set)
    __swig_setmethods__["eps"] = _Primme.primme_params_eps_set
    __swig_getmethods__["eps"] = _Primme.primme_params_eps_get
    if _newclass:
        eps = _swig_property(_Primme.primme_params_eps_get, _Primme.primme_params_eps_set)
    __swig_setmethods__["printLevel"] = _Primme.primme_params_printLevel_set
    __swig_getmethods__["printLevel"] = _Primme.primme_params_printLevel_get
    if _newclass:
        printLevel = _swig_property(_Primme.primme_params_printLevel_get, _Primme.primme_params_printLevel_set)
    __swig_setmethods__["initBasisMode"] = _Primme.primme_params_initBasisMode_set
    __swig_getmethods__["initBasisMode"] = _Primme.primme_params_initBasisMode_get
    if _newclass:
        initBasisMode = _swig_property(_Primme.primme_params_initBasisMode_get, _Primme.primme_params_initBasisMode_set)
    __swig_setmethods__["ldevecs"] = _Primme.primme_params_ldevecs_set
    __swig_getmethods__["ldevecs"] = _Primme.primme_params_ldevecs_get
    if _newclass:
        ldevecs = _swig_property(_Primme.primme_params_ldevecs_get, _Primme.primme_params_ldevecs_set)
    __swig_setmethods__["ldOPs"] = _Primme.primme_params_ldOPs_set
    __swig_getmethods__["ldOPs"] = _Primme.primme_params_ldOPs_get
    if _newclass:
        ldOPs = _swig_property(_Primme.primme_params_ldOPs_get, _Primme.primme_params_ldOPs_set)
    __swig_setmethods__["projectionParams"] = _Primme.primme_params_projectionParams_set
    __swig_getmethods__["projectionParams"] = _Primme.primme_params_projectionParams_get
    if _newclass:
        projectionParams = _swig_property(_Primme.primme_params_projectionParams_get, _Primme.primme_params_projectionParams_set)
    __swig_setmethods__["restartingParams"] = _Primme.primme_params_restartingParams_set
    __swig_getmethods__["restartingParams"] = _Primme.primme_params_restartingParams_get
    if _newclass:
        restartingParams = _swig_property(_Primme.primme_params_restartingParams_get, _Primme.primme_params_restartingParams_set)
    __swig_setmethods__["correctionParams"] = _Primme.primme_params_correctionParams_set
    __swig_getmethods__["correctionParams"] = _Primme.primme_params_correctionParams_get
    if _newclass:
        correctionParams = _swig_property(_Primme.primme_params_correctionParams_get, _Primme.primme_params_correctionParams_set)
    __swig_setmethods__["stats"] = _Primme.primme_params_stats_set
    __swig_getmethods__["stats"] = _Primme.primme_params_stats_get
    if _newclass:
        stats = _swig_property(_Primme.primme_params_stats_get, _Primme.primme_params_stats_set)

    def __init__(self):
        this = _Primme.new_primme_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_params
    __del__ = lambda self: None
primme_params_swigregister = _Primme.primme_params_swigregister
primme_params_swigregister(primme_params)

PRIMME_DEFAULT_METHOD = _Primme.PRIMME_DEFAULT_METHOD
PRIMME_DYNAMIC = _Primme.PRIMME_DYNAMIC
PRIMME_DEFAULT_MIN_TIME = _Primme.PRIMME_DEFAULT_MIN_TIME
PRIMME_DEFAULT_MIN_MATVECS = _Primme.PRIMME_DEFAULT_MIN_MATVECS
PRIMME_Arnoldi = _Primme.PRIMME_Arnoldi
PRIMME_GD = _Primme.PRIMME_GD
PRIMME_GD_plusK = _Primme.PRIMME_GD_plusK
PRIMME_GD_Olsen_plusK = _Primme.PRIMME_GD_Olsen_plusK
PRIMME_JD_Olsen_plusK = _Primme.PRIMME_JD_Olsen_plusK
PRIMME_RQI = _Primme.PRIMME_RQI
PRIMME_JDQR = _Primme.PRIMME_JDQR
PRIMME_JDQMR = _Primme.PRIMME_JDQMR
PRIMME_JDQMR_ETol = _Primme.PRIMME_JDQMR_ETol
PRIMME_SUBSPACE_ITERATION = _Primme.PRIMME_SUBSPACE_ITERATION
PRIMME_LOBPCG_OrthoBasis = _Primme.PRIMME_LOBPCG_OrthoBasis
PRIMME_LOBPCG_OrthoBasis_Window = _Primme.PRIMME_LOBPCG_OrthoBasis_Window

def sprimme(*args):
    return _Primme.sprimme(*args)
sprimme = _Primme.sprimme

def cprimme(*args):
    return _Primme.cprimme(*args)
cprimme = _Primme.cprimme

def dprimme(*args):
    return _Primme.dprimme(*args)
dprimme = _Primme.dprimme

def zprimme(*args):
    return _Primme.zprimme(*args)
zprimme = _Primme.zprimme
primme_svds_largest = _Primme.primme_svds_largest
primme_svds_smallest = _Primme.primme_svds_smallest
primme_svds_closest_abs = _Primme.primme_svds_closest_abs
primme_svds_default = _Primme.primme_svds_default
primme_svds_hybrid = _Primme.primme_svds_hybrid
primme_svds_normalequations = _Primme.primme_svds_normalequations
primme_svds_augmented = _Primme.primme_svds_augmented
primme_svds_op_none = _Primme.primme_svds_op_none
primme_svds_op_AtA = _Primme.primme_svds_op_AtA
primme_svds_op_AAt = _Primme.primme_svds_op_AAt
primme_svds_op_augmented = _Primme.primme_svds_op_augmented
class primme_svds_stats(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_svds_stats, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_svds_stats, name)
    __repr__ = _swig_repr
    __swig_setmethods__["numOuterIterations"] = _Primme.primme_svds_stats_numOuterIterations_set
    __swig_getmethods__["numOuterIterations"] = _Primme.primme_svds_stats_numOuterIterations_get
    if _newclass:
        numOuterIterations = _swig_property(_Primme.primme_svds_stats_numOuterIterations_get, _Primme.primme_svds_stats_numOuterIterations_set)
    __swig_setmethods__["numRestarts"] = _Primme.primme_svds_stats_numRestarts_set
    __swig_getmethods__["numRestarts"] = _Primme.primme_svds_stats_numRestarts_get
    if _newclass:
        numRestarts = _swig_property(_Primme.primme_svds_stats_numRestarts_get, _Primme.primme_svds_stats_numRestarts_set)
    __swig_setmethods__["numMatvecs"] = _Primme.primme_svds_stats_numMatvecs_set
    __swig_getmethods__["numMatvecs"] = _Primme.primme_svds_stats_numMatvecs_get
    if _newclass:
        numMatvecs = _swig_property(_Primme.primme_svds_stats_numMatvecs_get, _Primme.primme_svds_stats_numMatvecs_set)
    __swig_setmethods__["numPreconds"] = _Primme.primme_svds_stats_numPreconds_set
    __swig_getmethods__["numPreconds"] = _Primme.primme_svds_stats_numPreconds_get
    if _newclass:
        numPreconds = _swig_property(_Primme.primme_svds_stats_numPreconds_get, _Primme.primme_svds_stats_numPreconds_set)
    __swig_setmethods__["elapsedTime"] = _Primme.primme_svds_stats_elapsedTime_set
    __swig_getmethods__["elapsedTime"] = _Primme.primme_svds_stats_elapsedTime_get
    if _newclass:
        elapsedTime = _swig_property(_Primme.primme_svds_stats_elapsedTime_get, _Primme.primme_svds_stats_elapsedTime_set)

    def __init__(self):
        this = _Primme.new_primme_svds_stats()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_svds_stats
    __del__ = lambda self: None
primme_svds_stats_swigregister = _Primme.primme_svds_stats_swigregister
primme_svds_stats_swigregister(primme_svds_stats)

class primme_svds_params(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, primme_svds_params, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, primme_svds_params, name)
    __repr__ = _swig_repr
    __swig_setmethods__["m"] = _Primme.primme_svds_params_m_set
    __swig_getmethods__["m"] = _Primme.primme_svds_params_m_get
    if _newclass:
        m = _swig_property(_Primme.primme_svds_params_m_get, _Primme.primme_svds_params_m_set)
    __swig_setmethods__["n"] = _Primme.primme_svds_params_n_set
    __swig_getmethods__["n"] = _Primme.primme_svds_params_n_get
    if _newclass:
        n = _swig_property(_Primme.primme_svds_params_n_get, _Primme.primme_svds_params_n_set)
    __swig_setmethods__["numProcs"] = _Primme.primme_svds_params_numProcs_set
    __swig_getmethods__["numProcs"] = _Primme.primme_svds_params_numProcs_get
    if _newclass:
        numProcs = _swig_property(_Primme.primme_svds_params_numProcs_get, _Primme.primme_svds_params_numProcs_set)
    __swig_setmethods__["procID"] = _Primme.primme_svds_params_procID_set
    __swig_getmethods__["procID"] = _Primme.primme_svds_params_procID_get
    if _newclass:
        procID = _swig_property(_Primme.primme_svds_params_procID_get, _Primme.primme_svds_params_procID_set)
    __swig_setmethods__["mLocal"] = _Primme.primme_svds_params_mLocal_set
    __swig_getmethods__["mLocal"] = _Primme.primme_svds_params_mLocal_get
    if _newclass:
        mLocal = _swig_property(_Primme.primme_svds_params_mLocal_get, _Primme.primme_svds_params_mLocal_set)
    __swig_setmethods__["nLocal"] = _Primme.primme_svds_params_nLocal_set
    __swig_getmethods__["nLocal"] = _Primme.primme_svds_params_nLocal_get
    if _newclass:
        nLocal = _swig_property(_Primme.primme_svds_params_nLocal_get, _Primme.primme_svds_params_nLocal_set)
    __swig_setmethods__["globalSumReal"] = _Primme.primme_svds_params_globalSumReal_set
    __swig_getmethods__["globalSumReal"] = _Primme.primme_svds_params_globalSumReal_get
    if _newclass:
        globalSumReal = _swig_property(_Primme.primme_svds_params_globalSumReal_get, _Primme.primme_svds_params_globalSumReal_set)
    __swig_setmethods__["numSvals"] = _Primme.primme_svds_params_numSvals_set
    __swig_getmethods__["numSvals"] = _Primme.primme_svds_params_numSvals_get
    if _newclass:
        numSvals = _swig_property(_Primme.primme_svds_params_numSvals_get, _Primme.primme_svds_params_numSvals_set)
    __swig_setmethods__["target"] = _Primme.primme_svds_params_target_set
    __swig_getmethods__["target"] = _Primme.primme_svds_params_target_get
    if _newclass:
        target = _swig_property(_Primme.primme_svds_params_target_get, _Primme.primme_svds_params_target_set)
    __swig_setmethods__["method"] = _Primme.primme_svds_params_method_set
    __swig_getmethods__["method"] = _Primme.primme_svds_params_method_get
    if _newclass:
        method = _swig_property(_Primme.primme_svds_params_method_get, _Primme.primme_svds_params_method_set)
    __swig_setmethods__["methodStage2"] = _Primme.primme_svds_params_methodStage2_set
    __swig_getmethods__["methodStage2"] = _Primme.primme_svds_params_methodStage2_get
    if _newclass:
        methodStage2 = _swig_property(_Primme.primme_svds_params_methodStage2_get, _Primme.primme_svds_params_methodStage2_set)
    __swig_setmethods__["intWorkSize"] = _Primme.primme_svds_params_intWorkSize_set
    __swig_getmethods__["intWorkSize"] = _Primme.primme_svds_params_intWorkSize_get
    if _newclass:
        intWorkSize = _swig_property(_Primme.primme_svds_params_intWorkSize_get, _Primme.primme_svds_params_intWorkSize_set)
    __swig_setmethods__["realWorkSize"] = _Primme.primme_svds_params_realWorkSize_set
    __swig_getmethods__["realWorkSize"] = _Primme.primme_svds_params_realWorkSize_get
    if _newclass:
        realWorkSize = _swig_property(_Primme.primme_svds_params_realWorkSize_get, _Primme.primme_svds_params_realWorkSize_set)
    __swig_setmethods__["locking"] = _Primme.primme_svds_params_locking_set
    __swig_getmethods__["locking"] = _Primme.primme_svds_params_locking_get
    if _newclass:
        locking = _swig_property(_Primme.primme_svds_params_locking_get, _Primme.primme_svds_params_locking_set)
    __swig_setmethods__["numOrthoConst"] = _Primme.primme_svds_params_numOrthoConst_set
    __swig_getmethods__["numOrthoConst"] = _Primme.primme_svds_params_numOrthoConst_get
    if _newclass:
        numOrthoConst = _swig_property(_Primme.primme_svds_params_numOrthoConst_get, _Primme.primme_svds_params_numOrthoConst_set)
    __swig_setmethods__["aNorm"] = _Primme.primme_svds_params_aNorm_set
    __swig_getmethods__["aNorm"] = _Primme.primme_svds_params_aNorm_get
    if _newclass:
        aNorm = _swig_property(_Primme.primme_svds_params_aNorm_get, _Primme.primme_svds_params_aNorm_set)
    __swig_setmethods__["eps"] = _Primme.primme_svds_params_eps_set
    __swig_getmethods__["eps"] = _Primme.primme_svds_params_eps_get
    if _newclass:
        eps = _swig_property(_Primme.primme_svds_params_eps_get, _Primme.primme_svds_params_eps_set)
    __swig_setmethods__["precondition"] = _Primme.primme_svds_params_precondition_set
    __swig_getmethods__["precondition"] = _Primme.primme_svds_params_precondition_get
    if _newclass:
        precondition = _swig_property(_Primme.primme_svds_params_precondition_get, _Primme.primme_svds_params_precondition_set)
    __swig_setmethods__["initSize"] = _Primme.primme_svds_params_initSize_set
    __swig_getmethods__["initSize"] = _Primme.primme_svds_params_initSize_get
    if _newclass:
        initSize = _swig_property(_Primme.primme_svds_params_initSize_get, _Primme.primme_svds_params_initSize_set)
    __swig_setmethods__["maxBasisSize"] = _Primme.primme_svds_params_maxBasisSize_set
    __swig_getmethods__["maxBasisSize"] = _Primme.primme_svds_params_maxBasisSize_get
    if _newclass:
        maxBasisSize = _swig_property(_Primme.primme_svds_params_maxBasisSize_get, _Primme.primme_svds_params_maxBasisSize_set)
    __swig_setmethods__["maxBlockSize"] = _Primme.primme_svds_params_maxBlockSize_set
    __swig_getmethods__["maxBlockSize"] = _Primme.primme_svds_params_maxBlockSize_get
    if _newclass:
        maxBlockSize = _swig_property(_Primme.primme_svds_params_maxBlockSize_get, _Primme.primme_svds_params_maxBlockSize_set)
    __swig_setmethods__["maxMatvecs"] = _Primme.primme_svds_params_maxMatvecs_set
    __swig_getmethods__["maxMatvecs"] = _Primme.primme_svds_params_maxMatvecs_get
    if _newclass:
        maxMatvecs = _swig_property(_Primme.primme_svds_params_maxMatvecs_get, _Primme.primme_svds_params_maxMatvecs_set)
    __swig_setmethods__["iseed"] = _Primme.primme_svds_params_iseed_set
    __swig_getmethods__["iseed"] = _Primme.primme_svds_params_iseed_get
    if _newclass:
        iseed = _swig_property(_Primme.primme_svds_params_iseed_get, _Primme.primme_svds_params_iseed_set)
    __swig_setmethods__["printLevel"] = _Primme.primme_svds_params_printLevel_set
    __swig_getmethods__["printLevel"] = _Primme.primme_svds_params_printLevel_get
    if _newclass:
        printLevel = _swig_property(_Primme.primme_svds_params_printLevel_get, _Primme.primme_svds_params_printLevel_set)
    __swig_setmethods__["stats"] = _Primme.primme_svds_params_stats_set
    __swig_getmethods__["stats"] = _Primme.primme_svds_params_stats_get
    if _newclass:
        stats = _swig_property(_Primme.primme_svds_params_stats_get, _Primme.primme_svds_params_stats_set)

    def __init__(self):
        this = _Primme.new_primme_svds_params()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_primme_svds_params
    __del__ = lambda self: None
primme_svds_params_swigregister = _Primme.primme_svds_params_swigregister
primme_svds_params_swigregister(primme_svds_params)


def sprimme_svds(*args):
    return _Primme.sprimme_svds(*args)
sprimme_svds = _Primme.sprimme_svds

def cprimme_svds(*args):
    return _Primme.cprimme_svds(*args)
cprimme_svds = _Primme.cprimme_svds

def dprimme_svds(*args):
    return _Primme.dprimme_svds(*args)
dprimme_svds = _Primme.dprimme_svds

def zprimme_svds(*args):
    return _Primme.zprimme_svds(*args)
zprimme_svds = _Primme.zprimme_svds
class PrimmeParams(primme_params):
    """
    Abstract class to specify the eigenvalue problem and the options for calling
    dprimme and zprimme.

    Example
    -------
    >>> import Primme, scipy.sparse, numpy as np
    >>> A = scipy.sparse.spdiags(range(100), [0], 100, 100) # sparse diag. matrix
    >>> class PP(Primme.PrimmeParams):
    ... 	def __init__(self):
    ... 		Primme.PrimmeParams.__init__(self)
    ... 	def matvec(self, X):
    ... 		return A*X
    >>> pp = PP()
    >>> pp.n = A.shape[0] # set problem dimension
    >>> pp.numEvals = 3   # set number of eigenvalues
    >>> pp.target = Primme.primme_largest # find the largest eigenvalues
    >>> pp.eps = 1e-6     # residual norm tolerance
    >>> evals = np.zeros(pp.numEvals)                    # store eigenvalues
    >>> evecs = np.zeros((pp.n, pp.numEvals), order='F') # store eigenvectors
    >>> norms = np.zeros(pp.numEvals)                    # store residual norms
    >>> ret = Primme.dprimme(evals, evecs, norms, pp) # call the solver
    >>> ret  # error code, 0 is success!
    0
    >>> pp.initSize # number of converged eigenpairs
    3
    >>> evals[0:pp.initSize] # converged values 
    array([ 99.,  98.,  97.])
    >>> # Time in seconds and A*v times that took
    >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
    0.5, 110

    """

    __swig_setmethods__ = {}
    for _s in [primme_params]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrimmeParams, name, value)
    __swig_getmethods__ = {}
    for _s in [primme_params]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PrimmeParams, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        Abstract class to specify the eigenvalue problem and the options for calling
        dprimme and zprimme.

        Example
        -------
        >>> import Primme, scipy.sparse, numpy as np
        >>> A = scipy.sparse.spdiags(range(100), [0], 100, 100) # sparse diag. matrix
        >>> class PP(Primme.PrimmeParams):
        ... 	def __init__(self):
        ... 		Primme.PrimmeParams.__init__(self)
        ... 	def matvec(self, X):
        ... 		return A*X
        >>> pp = PP()
        >>> pp.n = A.shape[0] # set problem dimension
        >>> pp.numEvals = 3   # set number of eigenvalues
        >>> pp.target = Primme.primme_largest # find the largest eigenvalues
        >>> pp.eps = 1e-6     # residual norm tolerance
        >>> evals = np.zeros(pp.numEvals)                    # store eigenvalues
        >>> evecs = np.zeros((pp.n, pp.numEvals), order='F') # store eigenvectors
        >>> norms = np.zeros(pp.numEvals)                    # store residual norms
        >>> ret = Primme.dprimme(evals, evecs, norms, pp) # call the solver
        >>> ret  # error code, 0 is success!
        0
        >>> pp.initSize # number of converged eigenpairs
        3
        >>> evals[0:pp.initSize] # converged values 
        array([ 99.,  98.,  97.])
        >>> # Time in seconds and A*v times that took
        >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
        0.5, 110

        """
        if self.__class__ == PrimmeParams:
            _self = None
        else:
            _self = self
        this = _Primme.new_PrimmeParams(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_PrimmeParams
    __del__ = lambda self: None

    def display(self):
        return _Primme.PrimmeParams_display(self)

    def set_method(self, method):
        return _Primme.PrimmeParams_set_method(self, method)

    def _set_targetShifts(self, targetShifts):
        return _Primme.PrimmeParams__set_targetShifts(self, targetShifts)

    def _get_targetShifts(self):
        return _Primme.PrimmeParams__get_targetShifts(self)

    def matvec(self, *args):
        return _Primme.PrimmeParams_matvec(self, *args)

    def prevec(self, *args):
        return _Primme.PrimmeParams_prevec(self, *args)

    def globalSum(self, *args):
        return _Primme.PrimmeParams_globalSum(self, *args)
    __swig_setmethods__["globalSum_set"] = _Primme.PrimmeParams_globalSum_set_set
    __swig_getmethods__["globalSum_set"] = _Primme.PrimmeParams_globalSum_set_get
    if _newclass:
        globalSum_set = _swig_property(_Primme.PrimmeParams_globalSum_set_get, _Primme.PrimmeParams_globalSum_set_set)
    def __disown__(self):
        self.this.disown()
        _Primme.disown_PrimmeParams(self)
        return weakref_proxy(self)
PrimmeParams_swigregister = _Primme.PrimmeParams_swigregister
PrimmeParams_swigregister(PrimmeParams)

class PrimmeSvdsParams(primme_svds_params):
    """
    Abstract class to specify the eigenvalue problem and the options for calling
    dprimme_svds and zprimme_svds.

    Example
    -------
    >>> import Primme, scipy.sparse, numpy as np
    >>> A = scipy.sparse.spdiags(range(1,11), [0], 100, 10) # sparse diag. rect. matrix
    >>> class PSP(Primme.PrimmeSvdsParams):
    ... 	def __init__(self):
    ... 		Primme.PrimmeSvdsParams.__init__(self)
    ... 	def matvec(self, X, transpose):
    ... 		return A*X if transpose == 0 else A.H*X
    >>> pp = PSP()
    >>> pp.m, pp.n = A.shape # set problem dimensions
    >>> pp.numSvals = 3   # set number of singular values to seek
    >>> pp.target = Primme.primme_svds_smallest # find the smallest singular values
    >>> pp.eps = 1e-6     # residual norm tolerance
    >>> svals = np.zeros(pp.numSvals)                     # store singular values
    >>> svecsl = np.zeros((pp.m, pp.numSvals), order='F') # store left singular vectors
    >>> svecsr = np.zeros((pp.n, pp.numSvals), order='F') # store right singular vectors
    >>> norms = np.zeros(pp.numSvals)                     # store residual norms
    >>> ret = Primme.dprimme_svds(svals, svecsl, svecsr, norms, pp) # call the solver
    >>> ret  # error code, 0 is success!
    0
    >>> pp.initSize # number of converged singular pairs
    3
    >>> svals[0:pp.initSize] # converged singular values 
    array([ 1.,  2.,  3.])
    >>> # Time in seconds and A*v times that took
    >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
    0.7, 94

    """

    __swig_setmethods__ = {}
    for _s in [primme_svds_params]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrimmeSvdsParams, name, value)
    __swig_getmethods__ = {}
    for _s in [primme_svds_params]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PrimmeSvdsParams, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        Abstract class to specify the eigenvalue problem and the options for calling
        dprimme_svds and zprimme_svds.

        Example
        -------
        >>> import Primme, scipy.sparse, numpy as np
        >>> A = scipy.sparse.spdiags(range(1,11), [0], 100, 10) # sparse diag. rect. matrix
        >>> class PSP(Primme.PrimmeSvdsParams):
        ... 	def __init__(self):
        ... 		Primme.PrimmeSvdsParams.__init__(self)
        ... 	def matvec(self, X, transpose):
        ... 		return A*X if transpose == 0 else A.H*X
        >>> pp = PSP()
        >>> pp.m, pp.n = A.shape # set problem dimensions
        >>> pp.numSvals = 3   # set number of singular values to seek
        >>> pp.target = Primme.primme_svds_smallest # find the smallest singular values
        >>> pp.eps = 1e-6     # residual norm tolerance
        >>> svals = np.zeros(pp.numSvals)                     # store singular values
        >>> svecsl = np.zeros((pp.m, pp.numSvals), order='F') # store left singular vectors
        >>> svecsr = np.zeros((pp.n, pp.numSvals), order='F') # store right singular vectors
        >>> norms = np.zeros(pp.numSvals)                     # store residual norms
        >>> ret = Primme.dprimme_svds(svals, svecsl, svecsr, norms, pp) # call the solver
        >>> ret  # error code, 0 is success!
        0
        >>> pp.initSize # number of converged singular pairs
        3
        >>> svals[0:pp.initSize] # converged singular values 
        array([ 1.,  2.,  3.])
        >>> # Time in seconds and A*v times that took
        >>> pp.stats.elapsedTime, pp.stats.numMatvecs # doctest: +SKIP
        0.7, 94

        """
        if self.__class__ == PrimmeSvdsParams:
            _self = None
        else:
            _self = self
        this = _Primme.new_PrimmeSvdsParams(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Primme.delete_PrimmeSvdsParams
    __del__ = lambda self: None

    def display(self):
        return _Primme.PrimmeSvdsParams_display(self)

    def set_method(self, method, methodStage1, methodStage2):
        return _Primme.PrimmeSvdsParams_set_method(self, method, methodStage1, methodStage2)

    def _set_targetShifts(self, targetShifts):
        return _Primme.PrimmeSvdsParams__set_targetShifts(self, targetShifts)

    def _get_targetShifts(self):
        return _Primme.PrimmeSvdsParams__get_targetShifts(self)

    def matvec(self, *args):
        return _Primme.PrimmeSvdsParams_matvec(self, *args)

    def prevec(self, *args):
        return _Primme.PrimmeSvdsParams_prevec(self, *args)

    def globalSum(self, *args):
        return _Primme.PrimmeSvdsParams_globalSum(self, *args)
    __swig_setmethods__["globalSum_set"] = _Primme.PrimmeSvdsParams_globalSum_set_set
    __swig_getmethods__["globalSum_set"] = _Primme.PrimmeSvdsParams_globalSum_set_get
    if _newclass:
        globalSum_set = _swig_property(_Primme.PrimmeSvdsParams_globalSum_set_get, _Primme.PrimmeSvdsParams_globalSum_set_set)
    def __disown__(self):
        self.this.disown()
        _Primme.disown_PrimmeSvdsParams(self)
        return weakref_proxy(self)
PrimmeSvdsParams_swigregister = _Primme.PrimmeSvdsParams_swigregister
PrimmeSvdsParams_swigregister(PrimmeSvdsParams)

import numpy as np
from scipy.sparse.linalg.interface import aslinearoperator

__docformat__ = "restructuredtext en"

_PRIMMEErrors = {
0: "success",
1: "reported only amount of required memory",
-1: "failed in allocating int or real workspace",
-2: "malloc failed in allocating a permutation integer array",
-3: "main_iter() encountered problem; the calling stack of the functions where the error occurred was printed in 'stderr'",
-4: "argument 'primme' is NULL",
-5: "'n' < 0 or 'nLocal' < 0 or 'nLocal' > 'n'",
-6: "'numProcs' < 1",
-7: "'matrixMatvec' is NULL",
-8: "'applyPreconditioner' is NULL and 'precondition' is not NULL",
-9: "'not used",
-10: "'numEvals' > 'n'",
-11: "'numEvals' < 0",
-12: "'eps' > 0 and 'eps' < machine precision",
-13: "'target' is not properly defined",
-14: "'target' is one of 'primme_largest_abs', 'primme_closest_geq', 'primme_closest_leq' or 'primme_closest_abs' but 'numTargetShifts' <= 0 (no shifts)",
-15: "'target' is one of 'primme_largest_abs', 'primme_closest_geq', 'primme_closest_leq' or 'primme_closest_abs' but 'targetShifts' is NULL  (no shifts array)",
-16: "'numOrthoConst' < 0 or 'numOrthoConst' > 'n'. (no free dimensions left)",
-17: "'maxBasisSize' < 2",
-18: "'minRestartSize' < 0 or 'minRestartSize' shouldn't be zero",
-19: "'maxBlockSize' < 0 or 'maxBlockSize' shouldn't be zero",
-20: "'maxPrevRetain' < 0",
-21: "'scheme' is not one of *primme_thick* or *primme_dtr*",
-22: "'initSize' < 0",
-23: "'locking' == 0 and 'initSize' > 'maxBasisSize'",
-24: "'locking' and 'initSize' > 'numEvals'",
-25: "'maxPrevRetain' + 'minRestartSize' >= 'maxBasisSize'",
-26: "'minRestartSize' >= 'n'",
-27: "'printLevel' < 0 or 'printLevel' > 5",
-28: "'convTest' is not one of 'primme_full_LTolerance', 'primme_decreasing_LTolerance', 'primme_adaptive_ETolerance' or 'primme_adaptive'",
-29: "'convTest' == 'primme_decreasing_LTolerance' and 'relTolBase' <= 1",
-30: "'evals' is NULL, but not 'evecs' and 'resNorms'",
-31: "'evecs' is NULL, but not 'evals' and 'resNorms'",
-32: "'resNorms' is NULL, but not 'evecs' and 'evals'",
-33: "'locking' == 0 and 'minRestartSize' < 'numEvals'",
-34: "'ldevecs' is less than 'nLocal'",
-35: "'ldOPs' is non-zero and less than 'nLocal'",
-36 : "not enough memory for realWork",
-37 : "not enough memory for intWork",
-38 : "'locking' == 0 and 'target' is 'primme_closest_leq' or 'primme_closet_geq'"
}

_PRIMMESvdsErrors = {
0   : "success",
1   : "reported only amount of required memory",
-1  : "failed in allocating int or real workspace",
-2  : "malloc failed in allocating a permutation integer array",
-3  : "main_iter() encountered problem; the calling stack of the functions where the error occurred was printed in 'stderr'",
-4  : "primme_svds is NULL",
-5  : "Wrong value for m or n or mLocal or nLocal",
-6  : "Wrong value for numProcs",
-7  : "matrixMatvec is not set",
-8  : "applyPreconditioner is not set but precondition == 1 ",
-9  : "numProcs >1 but globalSumDouble is not set",
-10 : "Wrong value for numSvals, it's larger than min(m, n)",
-11 : "Wrong value for numSvals, it's smaller than 1",
-13 : "Wrong value for target",
-14 : "Wrong value for method",
-15 : "Not supported combination of method and methodStage2",
-16 : "Wrong value for printLevel",
-17 : "svals is not set",
-18 : "svecs is not set",
-19 : "resNorms is not set",
-20 : "not enough memory for realWork",
-21 : "not enough memory for intWork"
}


class PrimmeError(RuntimeError):
    """
    PRIMME error
    """
    def __init__(self, err):
        self.err = err
        RuntimeError.__init__(self, "PRIMME error %d: %s" % (err, _PRIMMEErrors[err]))

class PrimmeSvdsError(RuntimeError):
    """
    PRIMME SVDS error
    """
    def __init__(self, err):
        self.err = err
        msg = ""
        if err >= -100:
            msg = _PRIMMESvdsErrors[err]
        elif err >= -200:
            msg = "Error from PRIMME first stage: " + _PRIMMEErrors[err+100]
        elif err >= -300:
            msg = "Error from PRIMME second stage: " + _PRIMMEErrors[err+200]
        RuntimeError.__init__(self, "PRIMME SVDS error %d: %s" % (err, msg))


def eigsh(A, k=6, M=None, sigma=None, which='LM', v0=None,
          ncv=None, maxiter=None, tol=0, return_eigenvectors=True,
          Minv=None, OPinv=None, mode='normal', lock=None,
          return_stats=False, maxBlockSize=0, minRestartSize=0,
          maxPrevRetain=0, method=None, **kargs):
    """
    Find k eigenvalues and eigenvectors of the real symmetric square matrix
    or complex Hermitian matrix A.

    Solves ``A * x[i] = w[i] * x[i]``, the standard eigenvalue problem for
    w[i] eigenvalues with corresponding eigenvectors x[i].

    If M is specified, solves ``A * x[i] = w[i] * M * x[i]``, the
    generalized eigenvalue problem for w[i] eigenvalues
    with corresponding eigenvectors x[i]

    Parameters
    ----------
    A : An N x N matrix, array, sparse matrix, or LinearOperator
        the operation A * x, where A is a real symmetric matrix or complex
        Hermitian.
    k : int, optional
        The number of eigenvalues and eigenvectors desired.
    M : An N x N matrix, array, sparse matrix, or LinearOperator
        (not supported yet)
        the operation M * x for the generalized eigenvalue problem

            A * x = w * M * x.

        M must represent a real, symmetric matrix if A is real, and must
        represent a complex, hermitian matrix if A is complex. For best
        results, the data type of M should be the same as that of A.
    sigma : real, optional
        Find eigenvalues near sigma.
    v0 : N x i, ndarray, optional
        Starting vectors for iteration.
    ncv : int, optional
        The maximum size of the basis
    which : str ['LM' | 'SM' | 'LA' | 'SA' | 'BE']
        If A is a complex hermitian matrix, 'BE' is invalid.
        Which `k` eigenvectors and eigenvalues to find:

            'LM' : Largest (in magnitude) eigenvalues

            'SM' : Smallest (in magnitude) eigenvalues

            'LA' : Largest (algebraic) eigenvalues

            'SA' : Smallest (algebraic) eigenvalues

            'BE' : Half (k/2) from each end of the spectrum (not supported)

        When sigma != None, 'which' refers to the shifted eigenvalues ``w'[i]``
    maxiter : int, optional
        Maximum number of iterations.
    tol : float
        Accuracy for eigenvalues (stopping criterion).
        The default value is sqrt of machine precision.
    Minv : (not supported)
    OPinv : N x N matrix, array, sparse matrix, or LinearOperator
        Preconditioner to accelerate the convergence. Usually it is an
        approximation of the inverse of (A - sigma*M).
    return_eigenvectors : bool
        Return eigenvectors (True) in addition to eigenvalues
    mode : string ['normal' | 'buckling' | 'cayley']
        Only 'normal' mode is supported.
    lock : N x i, ndarray, optional
        Seek the eigenvectors orthogonal to these ones. The provided
        vectors *should* be orthonormal. Useful to not converge some already
        computed solutions.
    maxBlockSize : int, optional
        Maximum number of vectors added at every iteration.
    minRestartSize : int, optional
        Number of approximate eigenvectors kept from last iteration in restart.
    maxPrevRetain: int, optional
        Number of approximate eigenvectors kept from previous iteration in
        restart. Also referred as +k vectors in GD+k.
    method : int, optional
        Preset method, one of:

        - DEFAULT_MIN_TIME : a variant of JDQMR,
        - DEFAULT_MIN_MATVECS : GD+k
        - DYNAMIC : choose dynamically between both previous methods.

        See a detailed description of the methods and other possible values
        in [2]_.

    report_stats : bool, optional
        If True, it is also returned extra information from PRIMME.

    Returns
    -------
    w : array
        Array of k eigenvalues
    v : array
        An array representing the `k` eigenvectors.  The column ``v[:, i]`` is
        the eigenvector corresponding to the eigenvalue ``w[i]``.
    stats : dict, optional (if return_stats)
        Extra information reported by PRIMME:

        - "numOuterIterations": number of outer iterations
        - "numRestarts": number of restarts
        - "numMatvecs": number of A*v
        - "numPreconds": number of OPinv*v
        - "elapsedTime": time that took 
        - "estimateMinEVal": the leftmost Ritz value seen
        - "estimateMaxEVal": the rightmost Ritz value seen
        - "estimateLargestSVal": the largest singular value seen
        - "rnorms" : ||A*x[i] - x[i]*w[i]||

    Raises
    ------
    PrimmeError
        When the requested convergence is not obtained.

        The PRIMME error code can be found as ``err`` attribute of the exception
        object.

    See Also
    --------
    scipy.sparse.linalg.eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A
    Primme.svds : singular value decomposition for a matrix A

    Notes
    -----
    This function is a wrapper to PRIMME functions to find the eigenvalues and
    eigenvectors [1]_.

    References
    ----------
    .. [1] PRIMME Software, https://github.com/primme/primme
    .. [2] Preset Methods, http://www.cs.wm.edu/~andreas/software/doc/readme.html#preset-methods

    Examples
    --------
    >>> import Primme, scipy.sparse
    >>> A = scipy.sparse.spdiags(range(100), [0], 100, 100) # sparse diag. matrix
    >>> evals, evecs = Primme.eigsh(A, 3, tol=1e-6, which='LA')
    >>> evals # the three largest eigenvalues of A
    array([ 99.,  98.,  97.])
    >>> evals, evecs = Primme.eigsh(A, 3, tol=1e-6, which='LA', lock=evecs)
    >>> evals # the next three largest eigenvalues
    array([ 96.,  95.,  94.])
    """

    A = aslinearoperator(A)
    if len(A.shape) != 2 or A.shape[0] != A.shape[1]:
        raise ValueError('A: expected square matrix (shape=%s)' % (A.shape,))

    if M is not None:
        raise ValueError('generalized problems (M != None) are not supported')

    class PP(PrimmeParams):
        def __init__(self):
            PrimmeParams.__init__(self)
        def matvec(self, X):
            return A.matmat(X)
        def prevec(self, X):
            return OPinv.matmat(X)

    pp = PP()

    pp.n = A.shape[0]

    if k <= 0 or k > pp.n:
        raise ValueError("k=%d must be between 1 and %d, the order of the "
                         "square input matrix." % (k, pp.n))
    pp.numEvals = k
    pp.correctionParams.precondition = 0 if OPinv is None else 1

    if which == 'LM':
        pp.target = primme_largest_abs
        if sigma is None:
            sigma = 0.0
    elif which == 'LA':
        pp.target = primme_largest
        sigma = None
    elif which == 'SA':
        pp.target = primme_smallest
        sigma = None
    elif which == 'SM':
        pp.target = primme_closest_abs
        if sigma is None:
            sigma = 0.0
    else:
        raise ValueError("which='%s' not supported" % which)

    if sigma is not None:
        pp.targetShifts = np.array([sigma], dtype=np.dtype('d'))

    pp.eps = tol

    if ncv is not None:
        pp.maxBasisSize = ncv

    if maxiter is not None:
        pp.maxMatvecs = maxiter

    if OPinv is not None:
        OPinv = aslinearoperator(OPinv)
        if OPinv.shape[0] != OPinv.shape[1] or OPinv.shape[0] != A.shape[0]:
            raise ValueError('OPinv: expected square matrix with same shape as A (shape=%s)' % (OPinv.shape,))
        pp.correctionParams.precondition = 1

    if lock is not None:
        if lock.shape[0] != pp.n:
            raise ValueError('lock: expected matrix with the same columns as A (shape=%s)' % (lock.shape,))
        pp.numOrthoConst = min(lock.shape[1], pp.n)

# Set other parameters
    for dk, dv in kargs.items():
      setattr(pp, dk, dv)

    if A.dtype.kind in frozenset(["b", "i", "u"]) or A.dtype.type is np.double:
        dtype = np.dtype("d")
    else:
        dtype = A.dtype

    if dtype.type is np.complex64:
        Xprimme = cprimme
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float32:
        Xprimme = sprimme
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float64:
        Xprimme = dprimme
        rtype = np.dtype(np.float64)
    else:
        Xprimme = zprimme
        rtype = np.dtype(np.float64)

    evals = np.zeros(pp.numEvals, rtype)
    norms = np.zeros(pp.numEvals, rtype)
    evecs = np.zeros((pp.n, pp.numOrthoConst+pp.numEvals), dtype, order='F')

    if lock is not None:
        np.copyto(evecs[:, 0:pp.numOrthoConst], lock[:, 0:pp.numOrthoConst])

    if v0 is not None:
        pp.initSize = min(v0.shape[1], pp.numEvals)
        np.copyto(evecs[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize],
            v0[:, 0:pp.initSize])

    if maxBlockSize:
        pp.maxBlockSize = maxBlockSize

    if minRestartSize:
        pp.minRestartSize = minRestartSize

    if maxPrevRetain:
        pp.restartingParams.maxPrevRetain = maxPrevRetain

    if method is not None:
        pp.set_method(method)

    err = Xprimme(evals, evecs, norms, pp)

    if err != 0:
        raise PrimmeError(err)

    evals = evals[0:pp.initSize]
    norms = norms[0:pp.initSize]
    evecs = evecs[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize]

    if return_stats:
        stats = dict((f, getattr(pp.stats, f)) for f in [
            "numOuterIterations", "numRestarts", "numMatvecs",
            "numPreconds", "elapsedTime", "estimateMinEVal",
            "estimateMaxEVal", "estimateLargestSVal"])
        stats['rnorms'] = norms
        return evals, evecs, stats
    else:
        return evals, evecs


def svds(A, k=6, ncv=None, tol=0, which='LM', v0=None,
         maxiter=None, return_singular_vectors=True,
         precAHA=None, precAAH=None, precAug=None,
         u0=None, locku0=None, lockv0=None,
         return_stats=False, maxBlockSize=0,
         method=None, methodStage1=None, methodStage2=None, **kargs):
    """
    Compute k singular values and vectors for a sparse matrix.

    Parameters
    ----------
    A : {sparse matrix, LinearOperator}
        Array to compute the SVD on, of shape (M, N)
    k : int, optional
        Number of singular values and vectors to compute.
        Must be 1 <= k < min(A.shape).
    ncv : int, optional
        The maximum size of the basis
    tol : float, optional
        Tolerance for singular values. Zero (default) means machine precision.
    which : str ['LM' | 'SM'] or number, optional
        Which `k` singular values to find:

            - 'LM' : largest singular values
            - 'SM' : smallest singular values
            - number : closest singular values to (referred as sigma later)

    u0 : ndarray, optional
        Left starting vectors for the iterations.

        Should be approximate left singular vectors. If only u0 or v0 is
        provided, the other is computed.
    v0 : ndarray, optional
        Right starting vectors for the iterations.
    maxiter : int, optional
        Maximum number of iterations.
    precAHA : {N x N matrix, array, sparse matrix, LinearOperator}, optional
        Approximate inverse of (A.H*A - sigma**2*I). If provided and M>N, it
        usually accelerates the convergence.
    precAAH : {M x M matrix, array, sparse matrix, LinearOperator}, optional
        Approximate inverse of (A*A.H - sigma**2*I). If provided and M<N, it
        usually accelerates the convergence.
    precAug : {(M+N) x (M+N) matrix, array, sparse matrix, LinearOperator}, optional
        Approximate inverse of ([zeros() A.H; zeros() A] - sigma*I). It usually
        accelerates the convergence if tol<dtype.eps**.5.
    locku0 : ndarray, optional
        Left orthogonal vector constrain.

        Seek singular triplets orthogonal to locku0 and lockv0. The provided vectors
        *should* be orthonormal. If only locku0 or lockv0 is provided, the other
        is computed. Useful to not converge some already computed solutions.
    lockv0 : ndarray, optional
        Right orthogonal vector constrain. See locku0.
    maxBlockSize : int, optional
        Maximum number of vectors added at every iteration.
    report_stats : bool, optional
        If True, it is also returned extra information from PRIMME.

    Returns
    -------
    u : ndarray, shape=(M, k), optional
        Unitary matrix having left singular vectors as columns.
        Returned if `return_singular_vectors` is True.
    s : ndarray, shape=(k,)
        The singular values.
    vt : ndarray, shape=(k, N), optional
        Unitary matrix having right singular vectors as rows.
        Returned if `return_singular_vectors` is True.
    stats : dict, optional (if return_stats)
        Extra information reported by PRIMME:

        - "numOuterIterations": number of outer iterations
        - "numRestarts": number of restarts
        - "numMatvecs": number of A*v
        - "numPreconds": number of OPinv*v
        - "elapsedTime": time that took 
        - "rnorms" : ||A*v[i] - u[i]*s[i]||

        Returned if `return_stats` is True.

    See Also
    --------
    Primme.eigsh : eigenvalue decomposition for a sparse symmetrix/complex Hermitian matrix A
    scipy.sparse.linalg.eigs : eigenvalues and eigenvectors for a general (nonsymmetric) matrix A

    Examples
    --------
    >>> import Primme, scipy.sparse
    >>> A = scipy.sparse.spdiags(range(1, 11), [0], 100, 10) # sparse diag. rect. matrix
    >>> svecs_left, svals, svecs_right = Primme.svds(A, 3, tol=1e-6, which='SM')
    >>> svals # the three smallest singular values of A
    array([ 1.,  2.,  3.])

    >>> import Primme, scipy.sparse
    >>> A = scipy.sparse.rand(10000, 100, random_state=10)
    >>> prec = scipy.sparse.spdiags(np.reciprocal(A.multiply(A).sum(axis=0)),
    ...           [0], 100, 100) # square diag. preconditioner
    >>> svecs_left, svals, svecs_right = Primme.svds(A, 3, which=6.0, tol=1e-6, precAHA=prec)
    >>> ["%.5f" % x for x in svals.flat] # the three closest singular values of A to 0.5
    ['5.99871', '5.99057', '6.01065']
    """

    A = aslinearoperator(A)

    m, n = A.shape

    if k <= 0 or k > min(n, m):
        raise ValueError("k=%d must be between 1 and min(A.shape)=%d" % (k, min(n, m)))

    if precAHA is not None:
        precAHA = aslinearoperator(precAHA)
        if precAHA.shape[0] != precAHA.shape[1] or precAHA.shape[0] != n:
            raise ValueError('precAHA: expected square matrix with size %d' % n)

    if precAAH is not None:
        precAAH = aslinearoperator(precAAH)
        if precAAH.shape[0] != precAAH.shape[1] or precAAH.shape[0] != m:
            raise ValueError('precAAH: expected square matrix with size %d' % m)

    if precAug is not None:
        precAug = aslinearoperator(precAug)
        if precAug.shape[0] != precAug.shape[1] or precAug.shape[0] != m+n:
            raise ValueError('precAug: expected square matrix with size %d' % (m+n))

    class PSP(PrimmeSvdsParams):
        def __init__(self):
            PrimmeSvdsParams.__init__(self)

        def matvec(self, X, transpose):
            if transpose == 0:
                return A.matmat(X)
            else:
                return A.H.matmat(X) 

        def prevec(self, X, mode):
            if mode == primme_svds_op_AtA and precAHA is not None:
                return precAHA.matmat(X)
            elif mode == primme_svds_op_AAt and precAAH is not None:
                return precAAH.matmat(X) 
            elif mode == primme_svds_op_augmented and precAug is not None:
                return precAug.matmat(X) 
            return X

    pp = PSP()

    pp.m = A.shape[0]
    pp.n = A.shape[1]

    pp.numSvals = k

    if which == 'LM':
        pp.target = primme_svds_largest
    elif which == 'SM':
        pp.target = primme_svds_smallest
    else:
        try:
            which = float(which)
        except:
            raise ValueError("which must be either 'LM', 'SM' or a number.")
        pp.target = primme_svds_closest_abs
        pp.targetShifts = np.array([which], dtype='d')

    pp.eps = tol

    if ncv:
        pp.maxBasisSize = ncv

    if maxiter:
# NOTE: every eigensolver iteration spend two matvecs*blockSize
        pp.maxMatvecs = maxiter*(maxBlockSize if maxBlockSize else 1)/2

    if maxBlockSize:
        pp.maxBlockSize = maxBlockSize

    if precAHA is not None or precAAH is not None or precAug is not None:
        pp.precondition = 1

    def check_pair(u, v, var_names):
        if ((u is not None and u.shape[0] != m) or
                (v is not None and v.shape[0] != n)):
            aux = v; v = u; u = aux

        if ((u is not None and u.shape[0] != m) or
                (v is not None and v.shape[0] != n)):
            aux = v; v = u; u = aux
            raise ValueError("%s don't have the expected number of rows." % var_names)

        if u is not None and v is not None and u.shape[1] != v.shape[1]:
            raise ValueError("%s don't have the same number of columns." % var_names)

        if u is not None and v is None:
            v, _ = np.linalg.qr(A.H.matmult(u))

        if v is not None and u is None:
            u, _ = np.linalg.qr(A.matmult(v))

        return u, v

    locku0, lockv0 = check_pair(locku0, lockv0, "lockv0 or locku0")

    if locku0 is not None:
        pp.numOrthoConst = min(locku0.shape[1], min(m,n))

# Set other parameters
    for dk, dv in kargs.items():
      setattr(pp, dk, dv)

    if A.dtype.kind in frozenset(["b", "i", "u"]) or A.dtype.type is np.double:
        dtype = np.dtype("d")
    else:
        dtype = A.dtype

    if dtype.type is np.complex64:
        Xprimme_svds = cprimme_svds
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float32:
        Xprimme_svds = sprimme_svds
        rtype = np.dtype(np.float32)
    elif dtype.type is np.float64:
        Xprimme_svds = dprimme_svds
        rtype = np.dtype(np.float64)
    else:
        Xprimme_svds = zprimme_svds
        rtype = np.dtype(np.float64)

    svals = np.zeros(pp.numSvals, rtype)
    svecsl = np.zeros((pp.m, pp.numOrthoConst+pp.numSvals), dtype, order='F')
    svecsr = np.zeros((pp.n, pp.numOrthoConst+pp.numSvals), dtype, order='F')
    norms = np.zeros(pp.numSvals, rtype)

    if locku0 is not None:
        np.copyto(svecsl[:, 0:pp.numOrthoConst], locku0[:, 0:pp.numOrthoConst])
        np.copyto(svecsr[:, 0:pp.numOrthoConst], lockv0[:, 0:pp.numOrthoConst])

    u0, v0 = check_pair(u0, v0, "v0 or u0")

    if v0 is not None:
        pp.initSize = min(v0.shape[1], pp.numSvals)
        np.copyto(svecsl[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize], u0[:, 0:pp.initSize])
        np.copyto(svecsr[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize], v0[:, 0:pp.initSize])

# Set method
    if method is not None or methodStage1 is not None or methodStage2 is not None:
        if method is None: method = primme_svds_default
        if methodStage1 is None: methodStage1 = PRIMME_DEFAULT_METHOD
        if methodStage2 is None: methodStage2 = PRIMME_DEFAULT_METHOD
        pp.set_method(method, methodStage1, methodStage2)

    err = Xprimme_svds(svals, svecsl, svecsr, norms, pp)

    if err != 0:
        raise PrimmeSvdsError(err)

    if return_stats:
        stats = dict((f, getattr(pp.stats, f)) for f in [
            "numOuterIterations", "numRestarts", "numMatvecs",
            "numPreconds", "elapsedTime"])
        stats["rnorms"] = norms

    if not return_singular_vectors:
        return svals if not return_stats else (svals, stats)

    svals = svals[0:pp.initSize]
    norms = norms[0:pp.initSize]
    svecsl = svecsl[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize]
    svecsr = svecsr[:, pp.numOrthoConst:pp.numOrthoConst+pp.initSize]

# Transpose conjugate svecsr
    svecsr = svecsr.T.conj()

    if not return_stats:
        return svecsl, svals, svecsr
    else:
        return svecsl, svals, svecsr, stats


PrimmeParams.targetShifts = property(PrimmeParams._get_targetShifts, PrimmeParams._set_targetShifts)
PrimmeSvdsParams.targetShifts = property(PrimmeSvdsParams._get_targetShifts, PrimmeSvdsParams._set_targetShifts)

# This file is compatible with both classic and new-style classes.


